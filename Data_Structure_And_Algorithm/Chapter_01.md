## 1、引入

先看一道题

如果a + b = 1000，且 a ^2 + b^2 = c^2 （a，b，c为自然数），如果求出a、b、c可能的组合？

如果采用枚举的方式进行计算的话，代码如下：

```python
import time
start = time.time()
for a in range(0, 1001):
    for b in range(0, 1001):
        for c in range(0, 1001):
            if a + b + c == 1000 and a**2 + b**2 == c**2:
                print(a,b,c)
end = time.time()
print("during {}".format(end - start))
```

## 2、算法的提出

### 2.1、算法的概念

算法是计算机处理信息的本质，因为计算机程序本质上是一个算法来告诉计算机确切的步骤来执行一个指定的任务。一般的，当算法在处理信息时，会从输入设备或数据的存储地址读取数据，把结果写入输出设备或某个存储地址供以后再调用

***算法是独立存在的一种解决问题的方法和思想***

对于算法而言，实现的语言并不重要，重要的是思想

### 2.2、算法的五大特性

1、输入：算法具有0个或多个输入

2、输出：算法至少有1个或多个输出

3、有穷性：算法在有限的步骤之后会自动结束而不会无限循环，并且每一个步骤可以在可接受的时间内完成

4、确定性：算法中的每一步都有确定的含义，不会出现二义性

5、可行性：算法的每一步都是可行的，也就是说每一步都能够执行有限的次数完成



## 3、算法效率衡量

### 3.1、执行时间反应算法效率

对于同一个问题，我们给出了两张解决算法，在两种算法的实现中，我们对程序的时间进行测算，发现两段程序执行的时间相差悬殊，由此可以得到结论：***实现算法程序的执行时间可以反应出算法的效率，即算法的优劣***

***单纯依靠运行的时间来比较算法的优劣并不一定是客观存在的***

### 3.2、时间复杂度与“大O标记法”

我们假定计算机执行算法每一个基本操作的时间是固定的一个时间单位，那么有多少个基本操作就代表会花费多少时间单位。

***对于算法的时间效率，我们可以用“大O标记法”来表示***

> “大O记法”：对于单调的整数函数f，如果存在一个整数函数g和实常数c > 0，使得对于充分大的n总有f(n) <= c*g(n) ，就是函数g是f的一个渐进函数（忽略常数），记为f(n) = O(g(n))，也就是说，在区域无穷的极限意义下，函数f的增长收到函数g的约束，亦即函数f与函数g的特征相似
>
> 时间复杂度：假设存在函数g，使得算法A处理规模为n的问题示例所用时间为T(n) = O(g(n))，则称O(g(n))为算法A的渐进时间复杂度，简称为时间复杂度，记为T(n)

### 3.3、如何理解“大O记法”

对于算法的时间性质和空间性质，最重要的是其数量级和趋势，这些是分析算法效率的主要部分，而计量算法基本操作数量的规模函数中那些常量因子可以忽略不计。例如，可以认为3n^2和100n^2属于同一量级，如果两个算法处理同样规模实例的代价分别为这两个函数，就认为他们的效率“差不多”，都是n^2级

### 3.4、最坏时间复杂度

分析算法时，存在几种考虑：

- 算法完成工作最少需要多少基本操作，即**最优时间复杂度**
- 算法完成工作最多需要多少基本操作，即**最坏时间复杂度**
- 算法完成工作平均需要多少基本操作，即**平均时间复杂度**

对于最优时间复杂度，其价值不高，因为它没有提供什么有用信息，其反应的只是最乐观最理想的情况，没有参考价值

对于最坏时间复杂度，提供了一个保证，表明算法在此种程度的基本操作中一定能完成工作

对于平均时间复杂度，是对算法的一个全面评价，因此它完整全面的反应了这个算法的性质。但另一方面，这种衡量并没有保证，不是每个计算都能在这个基本操作内完成。

***我们主要关注算法的最坏情况，亦即最坏时间复杂度***

### 3.5、时间复杂度的几条基本计算规则

1、基本操作，即只有常数项，认为其时间复杂度为O(1)

2、顺序结构，时间复杂度按**加法**进行计算

3、循环结构，时间复杂度按**乘法**进行计算

4、分支结构，时间复杂度**取最大值**

5、判断一个算法的效率时，往往只需要关注操作数量的最高此项，其他次要项和常数可以忽略

6、在没有特殊说明时，我们所分析的算法的时间复杂度都是指**最坏时间复杂度**

### 3.6、常见的时间复杂度

| 执行次数函数举例     | 阶       | 非正式术语 |
| -------------------- | -------- | ---------- |
| 12                   | O(1)     | 常数阶     |
| 2n + 3               | O(n)     | 线性阶     |
| 3n^2 + 2n +1         | O(n^2)   | 平方阶     |
| 5log2n + 20          | O(logn)  | 对数阶     |
| 2n + 3nlog2n + 19    | O(nlogn) | nlogn阶    |
| 6n^3 + 2n^2 + 3n + 4 | O(n^3)   | 立方阶     |
| 2^n                  | O(2^n)   | 指数阶     |

**所消耗的时间从小到大**

O(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < O(n^3) < O(2^n) < O(n!) < O(n^n)

### 3.7、数据结构

数据是一个抽象的概念，将其进行分类后得到程序设计语言中的基本类型：如 int、float、char 等。数据元素之间不是独立的，存在特定的关系，这种关系便是结构。数据结构指数据对象中数据元素之间的关系

### 3.8、算法与数据结构的区别

数据结构只是静态的描述了数据元素之间的关系

高效的程序需要在数据结构的基础上设计和选择算法

**程序 = 数据结构 + 算法**

***总结：算法是为了解决实际问题而设计的，数据结构是算法需要处理的问题载体***

### 3.9、抽象数据类型

抽象数据类型(ADT)的含义是指一个数据模型以及定义在此数学模型上的一组操作。即把数据类型和数据类型上的运算捆绑在一起，进行封装。引入抽象数据类型的目的是把数据类型的表示和数据类型上的运算的实现与这些数据类型和运算在程序中引用隔开，使他们相互独立









